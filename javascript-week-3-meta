INTRODUCTION TO FUNCTIONAL PROGRAMMING

- programming paradigms: different styles of coding
  functional programming (FP)
  object-oriented programming (OOP)

- in functional programming:
  there is a clear delineating between data and functions

- in object-oriented programming
  you combine both data and functions into objects

________________________________

RETURN VALUES FROM FUNCTIONS

- you can return values inside one function inside another function

  ex: 
  function doubleIt(num) {
    return num * 2
  }

  function objectMaker(val) {
    return {
      prop: val
    }
  }

objectMaker(doubleIt(100));
//{prop: 200}

________________________________

FUNCTION CALLING AND RECURSION

- functions that loop are useful unless if they run infinitely 

- recursion is a function that calls itself

- recursive functions can run infinitely if done incorrectly

- recursion is an alternative way to run repetitive code without loops

- to avoid infinite recursion, set counter starting value, incremement, and exit condition

  ex:
  let counter = 3;
  function.example() {
    console.log(counter);
    counter = counter - 1;
    if (counter === 0) return;
    example();

________________________________

INTRODUCTION TO SCOPE

see : https://www.freecodecamp.org/news/scope-in-javascript-global-vs-local-vs-block-scope/#how-to-access-local-variables


- scope determines which part of code are accessible and which are inaccessible

- global scope: code that's outside of a function

- local scope: code that's inside of a function

- if a variable is defined within a function, you can say that it's scoped to that function

- the scope chain: 
  chain of scope references a function has to its parent scope
  the process of searching for variables through multiple scopes
  starts with local or block and moves down to global scope 

- lexical scope:
  the scope of a function is determined by where the function is declared, not where it is called

    

________________________________

THE FUNCTIONAL PROGRAMMING PARADIGM

FP :
- when writing FP code data and functions are kept separate 

- in FP data is passed into functions when we want something computed

- in FP functions return new values and then use those values somewhere else in the code

  ex:

    function getDistance (mph, h) {
      return mph * h 
    }
    var mph = 60;
    var h = 2;
    var distance = getDistance(mph, h);
    console.log(distance);

 OOP:

- data and functionality are properties and methods inside objects

  ex:

    var virtualPet = {
      sleepy: true.
      nap: function() {}
    }

- in OOP methods update properties stored in object instead of generating new return values

- if we want to change sleepy property:

    var virtualPet = {
      sleepy: true,
      nap: function () {
        this.sleepy = false
      }
    }
  console.log(virtualPet.sleepy) // true
  virtualPet.nap()
  console.log(virtualPet.sleepy) // false

- OoP helps us model real-life objects 

- works best when grouping of properties and data in an object belong together

FP, important concepts:

- first-class functions
- higher-order function
- pure functions and side-effects

- first-class functions
  
  are values that we can: 
    pass into other functions like a string or number,
    save in a variable
    return from other functions
    
  are values just as strings or numbers

  ex: 
    function addTwoNums(a, b) {
      console.log(a + b);
    }

    function randomNum() {
      return Math.floor((Meth.random() * 10) + 1);
    function specificNum() {return 42};

    var useRandom = true;

    var getNumber;

    if(useRandom) {
      getNumber = randomNum;
    } else {
      getNumber = specificNum
    }
  
    addTwoNums (getNumber(), getNumber())

- higher order functions

  a function that has either one or both of the following characteristics"
    it accepts other functions as arguments
    it returns functions when invoked

  ex: 
    function addTwoNums(getNumber1, getNumber2) {
      console.log(getNumber1() + getNumber2());
    }

  this receives arguments then invokes and concatenates them

- pure functions and side-effects:

  returns the same result as long as it's given the same values

  ex:
    function addTwoNums(a, b) {
      console.log(a + b);
    }

  do not have side-effects, including:
    changing variables outside of the function
    calling a Browser API
    calling Math.random()

- impure functions
  use non-local variables for computing is output
  creates a side effect by modifying another variable

________________________________

SCOPING WITH VAR, LET, AND CONST

- functions can build local scope and block scope

- block scope: 
  a variable is only accessible within a code block, such as if, else, switch, for, and while
  variables with block scope are further nested than local scope
  local scoped variables are further nested than global scope
  occurs when you declare a variable using let or const
  unlike local scope where variables are accessible within their function, 
  block scoped variables are only accessible within their block

  ex (variable shadowing):

    let color = 'red';
    if (color == 'red') {
      let color == 'blue'
    }

  two unique instances of red variable, one in global scope, one in block scope
  one red variable shadows the other

- declaring variables with var keyword
  variable can be used before it is declared
  the same variable can be redeclared
  variables can be scoped to a function or scoped globally

- declaring variables with let and const
  variables can't be used before they are declared (but they eventually need to be declared)
  variables can't be redeclared
  variables are scoped to the block

- use let when the variable value might change

- use const when the variable value will not change

________________________________

COMPARING VAR, LET, AND CONST

- let and const is recommended

- from most to least lenient: var, let, const

________________________________

INTRODUCTION TO OBJECT-ORIENTED PROGRAMMING

- OOP uses objects to group data and functionality

- templates/classes are used to write code for multiple objects

- the this keyword makes a generic alias for all objects

________________________________

CLASSES

- classes are a blueprint you can use to build many objects

  ex:
    class Car {
      constructor(color, speed) {
    }

    turboOn() {
      console.log('The turbo is on.')
    }

  syntax:
  "class" followed by class name, capitalized, followed by curly brackets
  constructor function, with all parameters needed in parentheses, followed by curly brackets
  all properties of the function, using this keyword
  afer constructor is defined, add as many methods as you want, without "function," just method name

  accessing the function:
  name of car, specifically
  .name of function

    car1 = new Car(red, 100mph);
    car1.turboOn();

  ex:
    class Car {
      constructor(brand) {
        this.carname = brand;
      }
    }
    mycar =  new Car("Ford");

  ex :
  https://www.w3schools.com/JsrEF/jsref_constructor_class.asp

    class Car {
      constructor(brand) {
        this.carname = brand;
      }
    }
    present() {  
      return 'I have a ' + this.carname;
    }
    class Model extends Car {
      constructor(brand, mod) {
        super(brand);
        this.model = mod;
      }
    }
    show() {
      return this.present() + ,' it is a ' + this.model;
    }

  mycar = new Model ("Ford," "Mustang");
  document.getElementbyId('demo').innerHTML = mycar.show();

  "extends" keyword inherits all methods from another class 
  "super" method calls parent's constructor function
  objects using super inherit a function within a class

________________________________

OBJECT ORIENTED PROGRAMMING PRINCIPLES

- OOP helps developers mimic relationship between objects in real world

- OOP helps developers reason about relationships between objects in software

- OOP :
  allows you to write modular code
  makes code more flexible
  makes code reusable

- 4 fundamental OOP principles:
  1. inheritance
  2. encapsulation
  3. abstraction
  4. polymorphism

- objects exist in a hierarchical structure; all objects derive from the object class

- you can create objects with the Object.create() method

  ex:
    class Animal {/*class code here*/};
    var myDog = Object.create(Animal);
    console.log(Animal)

- you can also create objects with the "new" keyword

  ex:
    class Animal {/*class code here*/};
    var myDog = new Animal();
    console.log(Animal)

- inheritance:
  there is a base class of a thing
  there is one or more sub-classes of things that inherit the properties of the base class
  base class is also referred to as super-class
  there can be sub-sub-classes, which inherit from a sub-class

  ex:
    class Animal {/*class code here*/};
    class Bird extends Animal {/*class code here*/};
    class Eagle extends Bird {/*class code here*/}

- encapsulation:
  the process of making a code implementation hidden from other users
  other users can use code without knowing how code works

  ex:
    "abc".toUpperCase();

- abstraction:
  writing code in a way that makes it more generalized
  extracting the concepts of what you're trying to do, rather than dealing with a specific manifestation of that concept

- polymorphism:
  when the same function produces different results based on its context
    ex:
      
      ringing a bell on a bicycle vs. ringing a bell on a bike:
        const bicycle = {
          bell: function() {
            return "Ring, ring! Watch out, please!"
          }
        }
         const door = {
          bell: function() {
            return "Ring, ring! Come here, please!"
          }
        }

      accessing the bell() method on the bicycle and door objects
        bicycle.bell(); // "...Watch out, please!"
        door.bell(); // "...Come here, please!"

        the bell function is polymorphic

      the "thing" keyword
        function ringTheBell(thing) }
          console.log(thing.bell())
        }

        ringTheBell(bicycle); // "...Watch out, please!"  
        ringTheBell(door); // "...Come here, please!"  

________________________________

CONSTRUCTORS

- native objects: JavaScript's built-in objects 

- constructors allow us to build instances of native objects

- constructors must be capitalized

  ex : creating a new instance of the Date object
    new Date();
    //outputs datetime

- certain objects come with the constructor function
  for ex, running new Math() throws an Uncaught TypeError 
  the Math object is a static object whose properties can be accessed directly from Math() object

  ex:
    function Icecream(flavor) {
      this.flavor = flavor;
      this.meltIt = function() {
        console.log(`The ${this.flavor} icecream has melted`);
      }
    }

    let kiwiIceCream = new Icecream('kiwi');
    let appleIcecream = new Icecream('apple');
    kiwiIcecream;
    appleIcecream;

- string literal vs. string object

  let pear = 'pear';
  pear; // --> 'pear'

  vs.

  let apple = new String('apple');
  apple; // -->String {'apple'}

  the string literal, or primitive value will be more performant than the string object
  if you compare objects they will always return false because the space in memory which they occupy is unique
    new String('apple') === new String('apple') //--> false

- when constructing plain, regular objects, don't use constructors, use literal syntax: {}

- RegExp objects: regular expression objects
  used to pattern-match strings using regular expressions
  built using "new RegExp" code
  instead of using RegExp, use a pattern literal

    ex:
      "abcd".match(/d/); 
      //['d', index: 3, input: 'abcd', groups: undefined]

  avoid constructors with native objects like arrays, functions, and regexp


